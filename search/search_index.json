{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MkDocs de Angel Quero","text":"<p>Esta p\u00e1gina esta siendo editada al momento desde VScode</p>"},{"location":"#descripcion","title":"Descripci\u00f3n","text":"<p>Vamos a crear una p\u00e1gina en MKdocs para mostrar algunas de las practicas que hemos realizado anteriormente.</p>"},{"location":"1.11/","title":"iaw-practica-01-11","text":"<p>El cambio principal de esta practica con respecto a la anterior es que vamos a a\u00f1adir un servidor NFS, que tenga como clientes ambos Front-Ends.</p> <p>Para conseguir esto iremos paso a paso de la siguiente manera.</p>"},{"location":"1.11/#back-end","title":"Back-End","text":"<p>Lanzaremos tanto el \"install\" como el \"deploy\" configurando correctamente nuestras IPs privadas.</p> <p>Es importante que dejemos que el usuario se pueda utilizar desde ambos Front-Ends, por lo cual debe ser <code>172.31.%</code></p>"},{"location":"1.11/#front-ends","title":"Front-Ends","text":"<p>De la misma forma lanzaremos el \"install_lamp\" y el \"deploy\" de Wordpress. Obviamente con las nuevas variables.</p>"},{"location":"1.11/#load-balancer","title":"Load Balancer","text":"<p>Por ultimo antes de llegar a la parte nueva de esta practica, crearemos el balanceador de carga con \"Nginx\"</p>"},{"location":"1.11/#nfs","title":"NFS","text":""},{"location":"1.11/#servidor","title":"Servidor","text":"<p>Todo lo nuevo se divide en dos scripts, uno para el servidor y otro para los clientes.</p> <p>El del servidor constar\u00e1 de lo siguiente:</p> <p>Instalaremos el servicio de NFS con <code>apt install nfs-kernel-server</code></p> <p>Una vez hecho esto, crearemos el directorio raiz, ya que al no instalar Apache no lo tenemos. Para ello haremos <code>mkdir /var/www/html</code>. Cambiaremos los permisos para que no sean de ningun usuario o grupo, usando <code>sudo chown nobody:nogroup /var/www/html</code></p> <p>A continuaci\u00f3n copiaremos el siguiente archivo en \"/etc/exports\". Este archivo consta de:</p> <pre><code>/var/www/html NFS_FRONTEND_NETWORK(rw,sync,no_root_squash,no_subtree_check)\n</code></pre> <p>A continuaci\u00f3n cambiaremos ese \"NFS_FRONTEND_NETWORK\" con un \"sed\", para sustituirlo por la subred de nuestras instancias. La cual ser\u00eda <code>172.31.0.0/16</code></p> <p>Para terminar con este script reiniciaremos el servidor con <code>systenctl restart nfs-kernel-server</code></p>"},{"location":"1.11/#cliente","title":"Cliente","text":"<p>Para los dos clientes necesitamos crear el siguiente script:</p> <p>Instalaremos el NFS client mediante <code>apt install nfs-common</code></p> <p>Montaremos el servidor en el directorio raiz con <code>mount $NFS_SERVER_IP:/var/www/html /var/www/html</code> a\u00f1adiendo la IP privada del servidor NFS.</p> <p>Por ultimo a\u00f1adiremos una linea de configuracion a fstop para montar automaticamente el NFS. <code>echo \"$NFS_SERVER_IP:/var/www/html /var/www/html  nfs auto,nofail,noatime,nolock,intr,tcp,actimeo=1800 0 0\" &gt;&gt; /etc/fstab</code></p> <p>y por ultimo recargaremos con <code>systemctl daemon-reload</code></p>"},{"location":"1.11/#comprobaciones","title":"Comprobaciones","text":"<p>Para ver que nuestro NFS esta montado en cada uno de nuestros Front-Ends, necesitaremos lanzar el comando <code>df -h</code>. Una vez veamos que est\u00e1 presente ya estar\u00e1 terminado. </p>"},{"location":"3.2/","title":"iaw-practica-3.2","text":"<p>Para esta practica debemos a\u00f1adir unos cuantos playbooks a los realizados en la practica 3.1 y cambiar nuestro despliegue de aplicaci\u00f3n para que sea Wordpress.</p> <p>Para ello vamos a comenzar por crear y definir nuestra infraestructura. Necesitaremos dos Front-Ends, un Back-End, un NFS y un Load Balancer.</p> <p>Una vez listo pasaremos a crear los archivos que necesitamos y los playbooks</p>"},{"location":"3.2/#templates","title":"Templates","text":"<p>Necesitamos un <code>000-default.conf</code> con el siguiente contenido:</p> <pre><code>ServerSignature Off\nServerTokens Prod\n\n&lt;VirtualHost *:80&gt;\n    #ServerName www.example.com\n    DocumentRoot /var/www/html\n    DirectoryIndex index.php index.html\n\n    &lt;Directory \"/var/www/html\"&gt;\n        AllowOverride All\n    &lt;/Directory&gt;\n\n    ErrorLog ${APACHE_LOG_DIR}/error.log \n    CustomLog ${APACHE_LOG_DIR}/access.log combined\n&lt;/VirtualHost&gt;\n</code></pre> <p>Un <code>load-balancer.conf</code> que contenga lo siguiente:</p> <pre><code>upstream frontend_servers {\n    server IP_FRONTEND_1;\n    server IP_FRONTEND_2;\n}\n\nserver {\n    listen 80;\n    server_name _;\n\n    location / {\n        proxy_pass http://frontend_servers;\n    }\n}\n</code></pre> <p>Un \"export\" para nuestro NFS Server que tenga la siguiente linea <code>/var/www/html NFS_FRONTEND_NETWORK(rw,sync,no_root_squash,no_subtree_check)</code></p> <p>Y por ultimo un <code>.htacces</code> para que correcto funcionamiento de Wordpress que tenga:</p> <pre><code># BEGIN WordPress\n&lt;IfModule mod_rewrite.c&gt;\nRewriteEngine On\nRewriteBase /\nRewriteRule ^index\\.php$ - [L]\nRewriteCond %{REQUEST_FILENAME} !-f\nRewriteCond %{REQUEST_FILENAME} !-d\nRewriteRule . /index.php [L]\n&lt;/IfModule&gt;\n# END WordPress\n</code></pre> <p>Una vez listo pasaremos a los playbooks</p>"},{"location":"3.2/#playbooks","title":"Playbooks","text":"<p>Comenzaremos por nuestro <code>install_lamp_frontend</code>, <code>setup_letsencrypt_https</code> y <code>install_lamp_backend</code> el cual no se diferencia de la practica anterior, a excepci\u00f3n de usar \"nginx\" en nuestro Let`s Encrypt.</p> <p>Crearemos dos mas para NFS, uno para el servidor y otro para el cliente lo cuales constaran de:</p> <p>Para el server, instalaremos \"nfs-kernel-server\", crearemos el directorio <code>var/www/html</code>, y cambiaremos los propietarios por \"nobody:nogroup\".  Una vez listo eso, copiaremos nuestro archivo \"exports\" en <code>etc/exports</code> y lo modificaremos usando:</p> <pre><code>    - name: Reemplazamos el FrontEnd_Network\n      replace:\n        path: /etc/exports\n        regexp: NFS_FRONTEND_NETWORK\n        replace: \"{{ nfs.network }}\"\n</code></pre> <p>Para el cliente, instalaremos \"nfs-common\" y montaremos el punto de enlace con:</p> <pre><code>    - name: Montamos el punto de cliente\n      mount:\n        path: /var/www/html\n        src: \"{{ nfs.server_ip }}:/var/www/html\"\n        fstype: nfs\n        state: mounted\n</code></pre> <p>Para reiniciarlo para terminar.</p> <p>Vamos a pasar a la configuraci\u00f3n de nuestro \"setup_loadbalancer\", en el cual vamos a instalar \"nginx\" y copiar nuestro archivo \"load-balancer.conf\". Despues vamos a deactivar el archivo por defecto y a modificar las IPs mediante:</p> <pre><code>    - name: Modificamos la ip del frontend1\n      replace:\n        path: /etc/nginx/sites-available/load-balancer.conf\n        regexp: IP_FRONTEND_1\n        replace: \"{{ ip.frontend1 }}\"\n</code></pre> <p>El cual repetiremos para la IP del Front-End 2 y el \"server_name\".  Despues solo tendremos que habilitar el nuevo host y reiciar el servicio.</p> <p>Por ultimo vamos con el \"deploy_wordpress\", comenzaremos como siempre por borrar las instalaciones previas y descargar el codigo fuente de Wordpress.  Modificaremos el propietario de <code>var/www/html</code> y, una vez descomprimido, descargaremos el codigo fuente de Wordpress.</p> <p>Ahora pasaremos a la instalaci\u00f3n y la configuraci\u00f3n de valores, la cual consta de:</p> <pre><code>    - name: Instalar Wordpress\n      command:\n        wp config create \\\n          --dbname={{ db.name }} \\\n          --dbuser={{ db.user }} \\\n          --dbpass={{ db.password }} \\\n          --dbhost={{ ip.backend }} \\\n          --path=/var/www/html/ \\\n          --allow-root\n\n    - name: Configuramos valores de instalacion\n      command:\n        wp core install \\\n          --url={{ certbot.domain }} \\\n          --title=\"{{ wordpress.tittle }}\" \\\n          --admin_user={{ wordpress.user }} \\\n          --admin_password={{ wordpress.pass }} \\\n          --admin_email={{ certbot.email }} \\\n          --path=/var/www/html \\\n          --allow-root\n</code></pre> <p>Para terminar vamos a definir algunas caracter\u00edsticas de Wordpress al igual que en practicas pasadas, modificar alguna variable y copiar nuestro \".htacces\", todo esto lo haremos con los siguientes comandos:</p> <pre><code>    - name: Actualizamos el wordpress\n      command: wp core update --path=/var/www/html --allow-root\n\n    - name: Actualizamos los temas\n      command: wp theme update --all --path=/var/www/html --allow-root\n\n    - name: A\u00f1adimos un tema\n      command: wp theme install {{wordpress.tema}} --activate --path=/var/www/html --allow-root\n\n    - name: Actualizamos los plugins\n      command: wp plugin update --all --path=/var/www/html --allow-root\n\n    - name: Instalamos bbpress\n      command: wp plugin install {{wordpress.plugin1}} --activate --path=/var/www/html --allow-root\n\n    - name: Instalamos hide-login\n      command: wp plugin install {{wordpress.plugin2}} --activate --path=/var/www/html --allow-root\n\n    - name: Cambiamos la estructura de las url\n      command: wp rewrite structure '/%postname%/' --path=/var/www/html --allow-root\n\n    - name: Cambiamos el /login por algo personalzado\n      command: wp option update whl_page 'acceso' --path=/var/www/html --allow-root\n\n    - name: A\u00f1adimos una variable\n      shell: sed -i \"/table_prefix = 'wp_';/a \\$_SERVER['HTTPS'] = 'on';\" /var/www/html/wp-config.php\n\n    - name: Copiamos el htaccess a /var/www/html\n      copy:\n        src: ../templates/.htaccess\n        dest: /var/www/html\n        mode: 0755\n</code></pre> <p>Con esto la tendriamos listo nuestro Wordpress y podemos pasar a probar el funcionamiento.</p>"},{"location":"3.2/#comprobacion","title":"Comprobaci\u00f3n","text":"<p>Capturas de los scripts funcionando:</p> <p></p> <p> (El error es porque el archivo estaba descargado anteriormente por tirar varias veces el script, pero funciona correctamente)</p> <p>Podemos ver que nuestro Wordpress esta correctamente desplegado</p> <p></p>"},{"location":"4.1/","title":"iaw-practica-4.1","text":"<p>Para esta practica debemos realizar una serie de actividades donde acabaremos por crear la infraestructura de nuestra practica anterior, 1.11.</p>"},{"location":"4.1/#ejercicio-1","title":"Ejercicio 1","text":"<p>Para el primer ejercicio debemos crear el grupo de seguridad para un Back-End.</p> <p>Usaremos el siguiente contenido en nuestro script para crearlo:</p> <pre><code># Creamos el grupo de seguridad: backend-sg\naws ec2 create-security-group \\\n    --group-name $SECURITY_GROUP_BACKEND \\\n    --description \"Reglas para el backend\"\n\n# Creamos una regla de accesso SSH\naws ec2 authorize-security-group-ingress \\\n    --group-name $SECURITY_GROUP_BACKEND \\\n    --protocol tcp \\\n    --port 22 \\\n    --cidr 0.0.0.0/0\n\n# Creamos una regla de accesso para MySQL\naws ec2 authorize-security-group-ingress \\\n    --group-name $SECURITY_GROUP_BACKEND \\\n    --protocol tcp \\\n    --port 3306 \\\n    --cidr 0.0.0.0/0\n</code></pre>"},{"location":"4.1/#ejercicio-2","title":"Ejercicio 2","text":"<p>Ahora crearemos la instancia del Back-End como tal, usando:</p> <pre><code># Creamos una intancia EC2 para el back end\naws ec2 run-instances \\\n    --image-id $AMI_ID \\\n    --count $COUNT \\\n    --instance-type $INSTANCE_TYPE \\\n    --key-name $KEY_NAME \\\n    --security-groups $SECURITY_GROUP_BACKEND \\\n    --tag-specifications \"ResourceType=instance,Tags=[{Key=Name,Value=$INSTANCE_NAME_BACKEND}]\"\n</code></pre>"},{"location":"4.1/#ejercicio-3","title":"Ejercicio 3","text":"<p>Para este ejercicio vamos a recrear la practica 1.11, pero como en el ejercicio 6 vamos a realizar lo mismo lo veremos mas adelante</p>"},{"location":"4.1/#ejercicio-4","title":"Ejercicio 4","text":"<p>Para este ejercicio vamos a crear otra instancia, esta vez un Front-End y vamos a a\u00f1adirle una variable para que el sistema se actualice al iniciarse.</p> <pre><code># Creamos una intancia EC2 para el frontend\naws ec2 run-instances \\\n    --image-id $AMI_ID \\\n    --count $COUNT \\\n    --instance-type $INSTANCE_TYPE \\\n    --key-name $KEY_NAME \\\n    --security-groups $SECURITY_GROUP_FRONTEND \\\n    --user-data $USER_DATA \\\n    --tag-specifications \"ResourceType=instance,Tags=[{Key=Name,Value=$INSTANCE_NAME_FRONTEND}]\"\n</code></pre> <p>Esta variable es la de \"user-data\"</p>"},{"location":"4.1/#ejercicio-5","title":"Ejercicio 5","text":"<p>Vamos a listar las instancias que hemos creado</p> <pre><code># Obtener lista de instancias\naws ec2 describe-instances \\\n    --filters \"Name=instance-state-name,Values=running\" \\\n    --query \"Reservations[*].Instances[*].[Tags[?Key=='Name'].Value | [0], PublicIpAddress]\" \\\n    --output table\n</code></pre>"},{"location":"4.1/#ejercicio-6","title":"Ejercicio 6","text":"<p>Aqu\u00ed es donde crearemos la infraestructura de la practica 1.11</p> <p>Para comenzar vamos a crear todas los grupos de seguridad siguiendo la siguiente guia:</p> <pre><code># Creamos el grupo de seguridad: frontend-sg\naws ec2 create-security-group \\\n    --group-name $SECURITY_GROUP_FRONTEND \\\n    --description \"Reglas para el frontend\"\n\n# Creamos una regla de accesso SSH\naws ec2 authorize-security-group-ingress \\\n    --group-name $SECURITY_GROUP_FRONTEND \\\n    --protocol tcp \\\n    --port 22 \\\n    --cidr 0.0.0.0/0\n\n# Creamos una regla de accesso HTTP\naws ec2 authorize-security-group-ingress \\\n    --group-name $SECURITY_GROUP_FRONTEND \\\n    --protocol tcp \\\n    --port 80 \\\n    --cidr 0.0.0.0/0\n</code></pre> <p>Y cambiando las variables y los puertos dependiendo del grupo de seguridad.</p> <p>Ahora crearemos las maquinas usando la misma estructura que en el ejercicio 4</p> <p>Para seguir vamos a crear y asociar las IPs flopantes usando:</p> <pre><code># Obtenemos el Id de la instancia a partir de su nombre\nINSTANCE_ID1=$(aws ec2 describe-instances \\\n            --filters \"Name=tag:Name,Values=$INSTANCE_NAME_FRONTEND1\" \\\n                      \"Name=instance-state-name,Values=running\" \\\n            --query \"Reservations[*].Instances[*].InstanceId\" \\\n            --output text)\n\n# Creamos una IP el\u00e1stica\nELASTIC_IP1=$(aws ec2 allocate-address --query PublicIp --output text)\n\n# Asociamos la IP el\u00e1stica a la instancia del balanceador\naws ec2 associate-address --instance-id $INSTANCE_ID1 --public-ip $ELASTIC_IP1\n</code></pre> <p>Repetiremos esta estructura para todas las instancias.</p>"},{"location":"4.1/#comprobacion","title":"Comprobaci\u00f3n","text":"<p>Vamos a lanzar el script del Ejercicio 6 para comprobar que la infraestructura se crea correctamente</p> <p></p> <p>Creacion de un grupo de seguridad (el resto se repiten de este)</p> <p></p> <p>Creaci\u00f3n de una instancia (las demas se repiten al igual que esta)</p> <p>Para comprobar que estan todas, vamos a lanzar el Ejercicio 5</p> <p></p> <p></p> <p>Y dentro del AWS tambien podemos comprobarlo.</p>"}]}